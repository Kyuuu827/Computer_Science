## 🌈 Apache Kafka에 대하여

## Apache Kafka 란?
- Apache Kafka는 빠르고 확장 가능한 작업을 위해 데이터 피드의 분산 스트리밍, 파이프 라이닝 및 재생을 위한 실시간 스트리밍 데이터를 처리하기 위한 목적으로 설계된 오픈 소스 분산형 게시-구독 메시징 플랫폼이다.

- 카프카는 기본적으로 Publish-Subscribe 모델을 구현한 분산 메시징 시스템이다. Publish-Subscribe 모델은 데이터를 만들어내는 프로듀서(Producer, 생산자), 소비하는 컨슈머(Consumer, 소비자) 그리고 이 둘 사이에서 중재자 역할을 하는 브로커(Broker)로 구성된 느슨한 결합(Loosely Coupled)의 시스템이다. 

![](https://images.velog.io/images/lck0827/post/3709d8c9-3c02-4556-b2b7-fa519136c4a3/image.png)

### 구성요소
- **Event**
  - Producer와 Consumer가 데이터를 주고 받는 단위이다. 
- **Producer**
  - kafka에 이벤트를 게시(post)하는 클라이언트 어플리케이션을 의미한다. 
- **Consumer**
  - Topic을 구독하고 이로부터 얻어낸 이벤트를 처리하는 클라이언트 어플리케이션이다. 
- **Topic**
  - 이벤트가 쓰이는 곳. Producer는 Topic에 이벤트를 게시한다. 
  - Consumer는 Topic으로부터 이벤트를 가져와 처리한다. 
  - Topic은 파일시스템의 폴더와 유사하고 이벤트는 폴더의 파일과 유사하다. 
  ✔ **Partition**
  👉 Topic은 여러 Broker에 의해 분산 저장된다. 이렇게 분산된 Topic을 Partition이라 한다. 어떤 이벤트가 Partition에 저장될지는 이벤트의 Key에 의해 정해지며, 같은 키를 가지는 이벤트는 항상 같은 partition에 저장된다. 
  
![](https://images.velog.io/images/lck0827/post/20c5e168-2913-4f34-bf93-b1f69ad863f9/image.png)

### kafka의 특징
-  **다중 프로듀서, 다중 컨슈머**
카프카의 토픽에 여러 프로듀서가 동시에 메시지를 전송할 수 있다. 마찬가지로 카프카 토픽의 메시지를 여러 컨슈머들이 동시에 읽어 갈 수 있다. 뿐만 아니라 하나의 프로듀서가 여러 토픽에 메시지를 전송할 수도 있으며, 하나의 컨슈머가 여러 토픽에서 메시지를 읽어 갈 수도 있다. 
특히 **하나의 메시지를 여러 컨슈머가 읽어 갈 수 있는 측면이 카프카의 큰 강점으로 작용한다.**
이러한 다중 프로듀서, 다중 컨슈머의 지원을 통해 하나의 카프카 시스템으로 다양한 애플리케이션이 데이터를 주고 받을 수 있게 되었으며, 데이터의 생산자/소비자 관계도 유연하게 구성할 수 있게 되었다.

- **파일시스템에 저장**
기존의 메시징 시스템은 프로듀서가 전송한 메시지를 브로커의 메모리 상에 존재하는 큐(Queue)에 유지하고, 이후 컨슈머가 메시지를 읽어가면 큐에서 메시지를 제거한다.  
**카프카는 프로듀서가 생성한 메시지를 브로커가 위치한 서버의 파일 시스템에 저장한다.** 따라서 컨슈머는 프로듀서가 생성한 메시지를 바로바로 소비하지 않아도 되며 카프카가 메시지를 보존하고 있는 기간내에서는 언제든지 읽어 갈 수 있다.
이런 방식은 프로듀서와 컨슈머의 속도 차이가 있을 때 유용하다. 예를 들어 컨슈머 쪽에 장애가 생겼거나 순간적인 네트워크 트래픽 폭주로 처리가 늦어졌을 때 브로커의 동작에 큰 영향을 주지 않으면서 처리 속도를 따라갈 수 있게 해준다. 또한 컨슈머들이 데이터를 모았다가 처리하는 배치(batch) 처리를 가능하게 해주며, 컨슈머 쪽에서 에러가 생겼을 때 이전에 읽었던 데이터를 다시 읽을 수 있게 해준다.  
카프카 브로커가 파일 시스템에 저장한 메시지는 관리자에 의해 설정된 일정 보존 기간동안 사용가능하며 이후 브로커가 위치한 서버의 파일 시스템에서 삭제된다. 

- **확장성(Scalability)**
카프카 클러스터는 운영중에 확장이 용이하도록 설계되었다. 데이터 파이프라인을 구축한 초창기 적은 수의 브로커들로 클러스터를 운영하다가 시스템 트래픽이 높아지면 브로커를 추가해서 클러스터를 확장할 수 있다. 즉, 수평적인 확장 (Horizontally Scale, Scale out) 이 쉽게 이뤄진다. 
카프카 토픽에 메시지를 전송하는 프로듀서 역시 운영중에 얼마든지 증가시킬 수 있다. 
카프카에서 메시지를 읽어가는 컨슈머의 경우 컨슈머 그룹으로 묶이며 컨슈머 그룹에 컨슈머를 추가할 수 있다. 컨슈머 그룹에 컨슈머가 추가되면 컨슈머의 파티션 소유권(Ownership)이 재분배되는 리밸런스 과정을 거쳐 컨슈머 그룹에 속한 컨슈머들이 고르게 파티션을 할당 받게 된다. 결과적으로 컨슈머 역시 운영 중에 무난하게 추가될 수 있다.
카프카 토픽은 내부에서 파티션(Partition)이라는 세분화된 단위로 나뉘어 저장되는데 토픽의 파티션 개수도 운영중에 추가할 수 있다. 
이런 모든 확장 작업이 카프카 운영에 심각한 부담을 줄 정도는 아니며 쉽고 간편하게 이루어 질 수 있도록 설계되었다. 

- **고성능**
카프카는 대용량 실시간 로그 처리에 특화되어 있다. 일반적인 범용 메시징 시스템이 지원하는 몇 가지 기능을 포기하면서 높은 처리량(Throughput)을 갖도록 설계되었다. 
예를 들어 IBM Websphere MQ 같은 경우 복수의 큐(Queue)에 메시지들을 원자적(Atomically)으로 전달 할 수 있는 트랜잭션(Transaction) 기능을 제공한다. JMS의 경우 컨슈머가 메시지를 소비했는지 여부를 알 수 있는 기능도 제공한다. 
**카프카는 이런 기능을 배제하고 뛰어난 처리량(Throughput)을 갖도록 설계되었다.** 불필요한 기능을 제외하고 내부적으로 배치처리, 분산 처리와 같은 다양한 기법을 사용해 성능을 처리량을 최대로 끌어냈다. 

- **컨슈머의 pull 방식**
기존의 메시징 시스템의 경우 브로커가 컨슈머에게 데이터를 전달해주는 "Push 방식"을 채택한 경우가 많이 있다.
** 카프카는 컨슈머가 브로커에게서 메시지를 가져오는 "Pull 방식"을 채택했다.** 
Pull 방식을 사용하면 컨슈머의 처리량을 브로커가 고민할 필요가 없다. 컨슈머는 자신이 처리할 수 있는 만큼의 메시지만 브로커에게서 가져가면 되기 때문에 최적의 메시지처리 성능을 갖을 수 있다. 만일 컨슈머의 처리 속도가 프로듀서의 생산 속도보다 느리다면 컨슈머를 추가하여 처리량을 늘릴 수 있다. 또한 메시지를 모았다가 한번에 처리할 수 있는 배치처리도 간단하게 구현할 수 있게 되었다.


### 기존 메시징 시스템과 다른 점
- **디스크에 메시지 저장**

  - 기존 메시징 시스템과 가장 큰 특징이다.
  - 기존 메시징 시스템은 컨슈머가 메시지를 소비하면 큐에서 바로 메시지를 삭제한다.
  - 하지만, 카프카는 컨슈머가 메시지를 소비하더라도 디스크에 메시지를 일정기간 보관하기 때문에 메시지의 손실이 없다.(영속성)
  
- **멀티 프로듀서, 멀티 컨슈머**
  - 카프카의 경우 디스크에 메시지를 저장하는 특징으로 인해,
프로듀서와 컨슈머 모두 하나 이상의 메시지를 주고 받을 수 있다.

- **분산형 스트리밍 플랫폼**
  - 단일 시스템 대비 성능이 우수하며, 시스템 확장이 용이하다.
  - 일부 노드가 죽더라도 다른 노드가 해당 일을 지속한다.(고가용성)

- **페이지 캐시**
  - 카프카는 잔여 메모리를 이용해 디스크 Read/Write 를 하지 않고 페이지 캐시를 통한 Read/Write으로 인해 처리속도가 매우 빠르다.
  
- **배치 전송 처리**
  - 서버와 클라이언트 사이에서 빈번하게 발생하는 메시지 통신을 하나씩 처리할 경우 그만큼 네트워크 왕복의 오버헤드가 발생
  - 이로 인해, 메시지를 작은 단위로 묶어 배치 처리를 함으로써 속도 향상에 큰 도움을 줌


### kafka의 비지니스 이점
- Apache kafka는 아래와 같은 세 가지 주요 요구 사항을 염두에 두고 설계 되었다.

  - 데이터 분배 및 이용을 위한 게시/구독 메시징 모델 제공
  - 오랜 시간에 걸쳐 액세스하고 재생할 수 있는 데이터의 장기 저장 허용
  - 실시간 스트림 처리를 위해 실시간으로 데이터에 액세스하는 기능 지원
  
- 일부 메시징 시스템과 달리 트랜잭션 또는 다른 배포 모델에 대한 매력적인 부가 기능을 제공하지는 않는다. 스트림 처리를 지원하는 게시/구독 모델에 대한 데이터 분배를 제공하는 데 중점을 둔다.

- 처음부터 장기간 데이터 저장 및 데이터 재생을 제공하도록 설계되었으므로 Apache Kafka는 데이터 영속성, 내결함성 및 재생에 고유하게 접근할 수 있다. 이는 Apache Kafka가 클러스터에서 데이터 복제 영속성, 데이터 볼륨 및 로드 증가를 위해 파티션 간 데이터 공유, 토픽/파티션, 데이터 오프셋 및 컨슈머 그룹 이름을 사용하여 데이터 액세스를 허용함으로써 확장성을 처리하는 방법에서 알아볼 수 있다.

- Apache Kafka는 원래 실시간 로그 처리를 위한 통신 계층 역할을 하도록 설계되었기 때문에 자연스럽게 실시간 스트림 처리 애플리케이션에 어울린다. 따라서 Apache Kafka는 대량의 데이터를 실시간으로 배포할 수있는 통신 인프라를 활용하는 애플리케이션에 이상적으로 적합하다.


---

### 📝 Reference
1. https://kafka.apache.org/documentation/
2. https://www.tibco.com/ko/reference-center/what-is-apache-kafka
3. https://galid1.tistory.com/793
4. https://needjarvis.tistory.com/607
5. https://velog.io/@jaehyeong/Apache-Kafka%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80